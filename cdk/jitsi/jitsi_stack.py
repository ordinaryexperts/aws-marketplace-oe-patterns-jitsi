import os
import subprocess
from aws_cdk import (
    Aws,
    aws_ec2,
    aws_elasticloadbalancingv2,
    aws_iam,
    aws_route53,
    CfnCondition,
    CfnMapping,
    CfnParameter,
    CfnOutput,
    Fn,
    Stack,
    Tags,
    Token
)
from constructs import Construct

from oe_patterns_cdk_common.alb import Alb
from oe_patterns_cdk_common.asg import Asg
from oe_patterns_cdk_common.assets_bucket import AssetsBucket
from oe_patterns_cdk_common.dns import Dns
from oe_patterns_cdk_common.secret import Secret
from oe_patterns_cdk_common.vpc import Vpc

TWO_YEARS_IN_DAYS=731
if 'TEMPLATE_VERSION' in os.environ:
    template_version = os.environ['TEMPLATE_VERSION']
else:
    try:
        template_version = subprocess.check_output(["git", "describe"]).strip().decode('ascii')
    except:
        template_version = "CICD"

# When making a new development AMI:
# 1) $ ave oe-patterns-dev make ami-ec2-build
# 2) $ ave oe-patterns-dev make AMI_ID=ami-fromstep1 ami-ec2-copy
# 3) Copy the code that copy-image generates below

# AMI list generated by:
# make TEMPLATE_VERSION=4.0.0 ami-ec2-build
# on Thu Nov 28 04:25:35 UTC 2024.
AMI_ID="ami-0234569a3ad7ff79d"
AMI_NAME="ordinary-experts-patterns-jitsi-4.0.0-20241128-0411"
generated_ami_ids = {
    "af-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-east-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-northeast-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-northeast-2": "ami-XXXXXXXXXXXXXXXXX",
    "ap-northeast-3": "ami-XXXXXXXXXXXXXXXXX",
    "ap-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-2": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-3": "ami-XXXXXXXXXXXXXXXXX",
    "ca-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-central-2": "ami-XXXXXXXXXXXXXXXXX",
    "eu-north-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-south-2": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-2": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-3": "ami-XXXXXXXXXXXXXXXXX",
    "me-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "me-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "sa-east-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-east-2": "ami-XXXXXXXXXXXXXXXXX",
    "us-west-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-west-2": "ami-XXXXXXXXXXXXXXXXX",
    "us-east-1": "ami-0234569a3ad7ff79d"
}
# End generated code block.

# Sanity check: if this fails then make copy-image needs to be run...
assert AMI_ID == generated_ami_ids["us-east-1"]

class JitsiStack(Stack):

    def __init__(self, scope: Construct, id: str, **kwargs) -> None:
        super().__init__(scope, id, **kwargs)

        ami_mapping={
            "AMI": {
                "AMI": AMI_NAME
            }
        }
        for region in generated_ami_ids.keys():
            ami_mapping[region] = { "AMI": generated_ami_ids[region] }
        CfnMapping(
            self,
            "AWSAMIRegionMap",
            mapping=ami_mapping
        )

        #
        # PARAMETERS
        #

        custom_dot_env_parameter_arn_param = CfnParameter(
            self,
            "CustomDotEnvParameterArn",
            default="",
            description="Optional: ARN of SSM Parameter Store Secure String containing custom config to append to the auto-generated .env"
        )

        custom_config_js_parameter_arn_param = CfnParameter(
            self,
            "CustomConfigJsParameterArn",
            default="",
            description="Optional: ARN of SSM Parameter Store Secure String containing custom code to populate custom-config.js"
        )

        custom_interface_config_js_parameter_arn_param = CfnParameter(
            self,
            "CustomInterfaceConfigJsParameterArn",
            default="",
            description="Optional: ARN of SSM Parameter Store Secure String containing custom code to populate custom-interface-config.js"
        )

        #
        # RESOURCES
        #

        # vpc
        vpc = Vpc(
            self,
            "Vpc"
        )

        dns = Dns(self, "Dns")

        secret = Secret(self, "Jitsi")

        assets_bucket = AssetsBucket(
            self,
            "AssetsBucket"
        )

        asg_update_secret_policy = aws_iam.CfnRole.PolicyProperty(
            policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[
                            "secretsmanager:DescribeSecret",
                            "secretsmanager:UpdateSecret"
                        ],
                        resources=[secret.secret_arn()]
                    )
                ]
            ),
            policy_name="AllowUpdateInstanceSecret"
        )

        asg_assets_bucket_policy = aws_iam.CfnRole.PolicyProperty(
            policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[
                            "s3:*"
                        ],
                        resources=[ f"{assets_bucket.assets_bucket_arn}/*" ]
                    ),
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[
                            "s3:GetBucketCORS",
                            "s3:GetBucketLocation",
                            "s3:ListBucket",
                            "s3:PutBucketCORS"
                        ],
                        resources=[ assets_bucket.assets_bucket_arn ]
                    )
                ]
            ),
            policy_name="AllowUpdateBucket"
        )

        with open("jitsi/user_data.sh") as f:
            user_data = f.read()
        asg = Asg(
            self,
            "Asg",
            additional_iam_role_policies=[asg_update_secret_policy, asg_assets_bucket_policy],
            default_instance_type="t3.xlarge",
            secret_arns=[secret.secret_arn()],
            use_graviton=False,
            user_data_contents=user_data,
            user_data_variables={
                "Hostname": dns.hostname(),
                "SecretArn": secret.secret_arn(),
                "AssetsBucket": assets_bucket.bucket_name()
            },
            vpc=vpc
        )

        alb = Alb(
            self,
            "Alb",
            asg=asg,
            health_check_path = "/elb-check",
            vpc=vpc
        )

        nlb_sg = aws_ec2.CfnSecurityGroup(
            self,
            "NlbSg",
            group_description="{}/NlbSg".format(Aws.STACK_NAME),
            security_group_egress=[
                aws_ec2.CfnSecurityGroup.EgressProperty(
                    ip_protocol="-1",
                    cidr_ip="0.0.0.0/0",
                    description="all IPv4 egress traffic allowed"
                )
            ],
            vpc_id=vpc.id()
        )
        Tags.of(nlb_sg).add("Name", "{}/AlbSg".format(Aws.STACK_NAME))

        # in this case the ALB is behind the NLB
        alb.http_ingress.cidr_ip = None
        alb.http_ingress.description = 'Allow HTTP traffic from NLB'
        alb.http_ingress.source_security_group_id = nlb_sg.attr_group_id
        alb.https_ingress.cidr_ip = None
        alb.https_ingress.description = 'Allow HTTPS traffic from NLB'
        alb.https_ingress.source_security_group_id = nlb_sg.attr_group_id

        aws_ec2.CfnSecurityGroupIngress(
            self,
            "NlbSgHttpIngress",
            cidr_ip=alb.ingress_cidr_param.value_as_string,
            description="Allow HTTP traffic to NLB",
            from_port=80,
            group_id=nlb_sg.ref,
            ip_protocol="tcp",
            to_port=80
        )
        aws_ec2.CfnSecurityGroupIngress(
            self,
            "NlbSgHttpsIngress",
            cidr_ip=alb.ingress_cidr_param.value_as_string,
            description="Allow HTTPS traffic to NLB",
            from_port=443,
            group_id=nlb_sg.ref,
            ip_protocol="tcp",
            to_port=443
        )
        aws_ec2.CfnSecurityGroupIngress(
            self,
            "NlbSgJitsiIngress",
            cidr_ip=alb.ingress_cidr_param.value_as_string,
            description="Allow 10000 jvb UDP traffic to NLB",
            from_port=10000,
            group_id=nlb_sg.ref,
            ip_protocol="udp",
            to_port=10000
        )
        aws_ec2.CfnSecurityGroupIngress(
            self,
            "NlbSgJigasiIngress",
            cidr_ip=alb.ingress_cidr_param.value_as_string,
            description="Allow 20000-20040 jigasi UDP traffic to NLB",
            from_port=20000,
            group_id=nlb_sg.ref,
            ip_protocol="udp",
            to_port=20040
        )
        aws_ec2.CfnSecurityGroupIngress(
            self,
            "SgAsgJitsiIngress",
            description="Allow 10000 UDP traffic from NLB to ASG",
            from_port=10000,
            group_id=asg.sg.ref,
            ip_protocol="udp",
            source_security_group_id=nlb_sg.ref,
            to_port=10000
        )
        aws_ec2.CfnSecurityGroupIngress(
            self,
            "SgAsgJigasiIngress",
            description="Allow 20000-20040 UDP jigasi traffic from NLB to ASG",
            from_port=20000,
            group_id=asg.sg.ref,
            ip_protocol="udp",
            source_security_group_id=nlb_sg.ref,
            to_port=20040
        )

        nlb = aws_elasticloadbalancingv2.CfnLoadBalancer(
            self,
            "AppNlb",
            scheme="internet-facing",
            security_groups=[ nlb_sg.ref ],
            subnets=vpc.public_subnet_ids(),
            type="network"
        )
        Tags.of(nlb).add(
            "vpc-igw-attachment",
            Token.as_string(
                Fn.condition_if(
                    vpc.not_given_condition.logical_id,
                    Fn.select(0, Fn.split('|', vpc.igw_attachment.ref)),
                    "provided-by-user"
                )
            )
        )
        nlb.add_dependency(alb.http_listener)
        nlb.add_dependency(alb.https_listener)
        
        nlb_http_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "NlbHttpTargetGroup",
            port=80,
            protocol="TCP",
            target_type="alb",
            targets=[aws_elasticloadbalancingv2.CfnTargetGroup.TargetDescriptionProperty(
                id=alb.alb.ref
            )],
            vpc_id=vpc.id()
        )
        aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpListener",
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=nlb_http_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=nlb.ref,
            port=80,
            protocol="TCP"
        )

        nlb_https_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "NlbHttpsTargetGroup",
            port=443,
            protocol="TCP",
            target_type="alb",
            targets=[aws_elasticloadbalancingv2.CfnTargetGroup.TargetDescriptionProperty(
                id=alb.alb.ref
            )],
            vpc_id=vpc.id()
        )
        aws_elasticloadbalancingv2.CfnListener(
            self,
            "NlbHttpsListener",
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=nlb_https_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=nlb.ref,
            port=443,
            protocol="TCP"
        )

        jitsi_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "JitsiTargetGroup",
            port=10000,
            protocol="UDP",
            target_type="instance",
            vpc_id=vpc.id()
        )
        aws_elasticloadbalancingv2.CfnListener(
            self,
            "JitsiListener",
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=jitsi_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=nlb.ref,
            port=10000,
            protocol="UDP"
        )

        jigasi_target_groups = []
        # only going to 20040 instead of 20050 due to limit of
        # 50 listeners on load balancers
        for i in range(20000, 20040+1):
            target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
                self,
                f"JigasiTargetGroup{i}",
                port=i,
                protocol="UDP",
                target_type="instance",
                vpc_id=vpc.id()
            )
            aws_elasticloadbalancingv2.CfnListener(
                self,
                f"JigasiListener{i}",
                default_actions=[
                    aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                        target_group_arn=target_group.ref,
                        type="forward"
                    )
                ],
                load_balancer_arn=nlb.ref,
                port=i,
                protocol="UDP"
            )
            jigasi_target_groups.append(target_group.ref)

        asg.asg.target_group_arns = [jitsi_target_group.ref, alb.target_group.ref] + jigasi_target_groups

        record_set = aws_route53.CfnRecordSetGroup(
            self,
            "RecordSetGroup",
            hosted_zone_name=f"{dns.route_53_hosted_zone_name_param.value_as_string}.",
            comment=dns.hostname_param.value_as_string,
            record_sets=[
                aws_route53.CfnRecordSetGroup.RecordSetProperty(
                    name=f"{dns.hostname_param.value_as_string}.",
                    type="A",
                    alias_target=aws_route53.CfnRecordSetGroup.AliasTargetProperty(
                        dns_name=nlb.attr_dns_name,
                        hosted_zone_id=nlb.attr_canonical_hosted_zone_id
                    )
                )
            ]
        )
        asg.asg.add_dependency(record_set)

        CfnOutput(
            self,
            "FirstUseInstructions",
            description="Instructions for getting started",
            value="Click on the DnsSiteUrlOutput link to start a meeting. Check the GitHub repo for documentation: https://github.com/ordinaryexperts/aws-marketplace-oe-patterns-jitsi"
        )

        # AWS::CloudFormation::Interface
        parameter_groups = [
            {
                "Label": {
                    "default": "Application Config"
                },
                "Parameters": [
                    custom_dot_env_parameter_arn_param.logical_id,
                    custom_config_js_parameter_arn_param.logical_id,
                    custom_interface_config_js_parameter_arn_param.logical_id
                ]
            }
        ]
        parameter_groups += alb.metadata_parameter_group()
        parameter_groups += assets_bucket.metadata_parameter_group()
        parameter_groups += asg.metadata_parameter_group()
        parameter_groups += dns.metadata_parameter_group()
        parameter_groups += secret.metadata_parameter_group()
        parameter_groups += vpc.metadata_parameter_group()
        self.template_options.metadata = {
            "OE::Patterns::TemplateVersion": template_version,
            "AWS::CloudFormation::Interface": {
                "ParameterGroups": parameter_groups,
                "ParameterLabels": {
                    custom_dot_env_parameter_arn_param.logical_id: {
                        "default": "Custom .env configuration"
                    },
                    custom_config_js_parameter_arn_param.logical_id: {
                        "default": "custom-config.js contents"
                    },
                    custom_interface_config_js_parameter_arn_param.logical_id: {
                        "default": "custom-interface-config.js contents"
                    },
                    **alb.metadata_parameter_labels(),
                    **asg.metadata_parameter_labels(),
                    **assets_bucket.metadata_parameter_labels(),
                    **dns.metadata_parameter_labels(),
                    **secret.metadata_parameter_labels(),
                    **vpc.metadata_parameter_labels()
                }
            }
        }
