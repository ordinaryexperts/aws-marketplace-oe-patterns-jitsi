import json
import os
import subprocess
import yaml
from aws_cdk import (
    aws_autoscaling,
    aws_cloudformation,
    aws_cloudfront,
    aws_cloudwatch,
    aws_codebuild,
    aws_codedeploy,
    aws_codepipeline,
    aws_codepipeline_actions,
    aws_ec2,
    aws_efs,
    aws_elasticache,
    aws_elasticloadbalancingv2,
    aws_iam,
    aws_lambda,
    aws_logs,
    aws_rds,
    aws_s3,
    aws_secretsmanager,
    aws_sns,
    aws_ssm,
    core
)

TWO_YEARS_IN_DAYS=731
# TODO: uncomment after a release
#template_version = subprocess.check_output(["git", "describe"]).strip().decode('ascii')
template_version = "0.0"

# When making a new development AMI:
# 1) $ ave oe-patterns-dev make ami-ec2-build
# 2) $ ave oe-patterns-dev make AMI_ID=ami-fromstep1 ami-ec2-copy
# 3) Copy the code that copy-image generates below

# AMI list generated by:
# make AMI_ID=ami-0010e399ec2504e62 ami-ec2-copy
# on Wed Jun 17 16:43:17 UTC 2020.
AMI_ID="ami-0010e399ec2504e62"
AMI_NAME="ordinary-experts-patterns-drupal-0.3.0-100-gafd94f7-20200615-0354"
generated_ami_ids = {
    "us-east-2": "ami-012c742ab95a953f9",
    "us-west-1": "ami-048aa4c21ae584439",
    "us-west-2": "ami-0e012b82c5dd4f333",
    "ca-central-1": "ami-01f04b14738653bcc",
    "eu-central-1": "ami-0de7d502dd4331573",
    "eu-north-1": "ami-062ee1a08409bca9e",
    "eu-west-1": "ami-08ed657dd581a0b56",
    "eu-west-2": "ami-0c136f09703954854",
    "eu-west-3": "ami-0f87004df30cb6f8c",
    "ap-northeast-1": "ami-06a2de1d64f2b253c",
    "ap-northeast-2": "ami-034ce8a156e9e2b3a",
    "ap-south-1": "ami-0ff11c7da94d5c246",
    "ap-southeast-1": "ami-084ae2b11d220b46f",
    "ap-southeast-2": "ami-0b4e420d8dac3c86b",
    "sa-east-1": "ami-040dbc89d9efdb5db",
   "us-east-1": "ami-0010e399ec2504e62"
}
# End generated code block.

# Sanity check: if this fails then make copy-image needs to be run...
assert AMI_ID == generated_ami_ids["us-east-1"]

class JitsiStack(core.Stack):

    def __init__(self, scope: core.Construct, id: str, **kwargs) -> None:
        super().__init__(scope, id, **kwargs)

        current_directory = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
        allowed_values = yaml.load(
            open(os.path.join(current_directory, "allowed_values.yaml")),
            Loader=yaml.SafeLoader
        )
        ami_mapping={
            "AMI": {
                "OEDRUPAL": AMI_NAME
            }
        }
        for region in generated_ami_ids.keys():
            ami_mapping[region] = { "OEDRUPAL": generated_ami_ids[region] }
        aws_ami_region_map = core.CfnMapping(
            self,
            "AWSAMIRegionMap",
            mapping=ami_mapping
        )

        # utility function to parse the unique id from the stack id for
        # shorter resource names  using cloudformation functions
        def append_stack_uuid(name):
            return core.Fn.join("-", [
                name,
                core.Fn.select(0, core.Fn.split("-", core.Fn.select(2, core.Fn.split("/", core.Aws.STACK_ID))))
            ])

        #
        # PARAMETERS
        #

        certificate_arn_param = core.CfnParameter(
            self,
            "CertificateArn",
            default="",
            description="Optional: Specify the ARN of a ACM Certificate to configure HTTPS."
        )
        notification_email_param = core.CfnParameter(
            self,
            "NotificationEmail",
            default="",
            description="Optional: Specify an email address to get emails about deploys and other system events."
        )
        vpc_id_param = core.CfnParameter(
            self,
            "VpcId",
            default="",
            description="Optional: Specify the VPC ID.  If not specified, a VPC will be created."
        )
        vpc_private_subnet_id1_param = core.CfnParameter(
            self,
            "VpcPrivateSubnetId1",
            default="",
            description="Optional: Specify Subnet ID for first private subnet."
        )
        vpc_private_subnet_id2_param = core.CfnParameter(
            self,
            "VpcPrivateSubnetId2",
            default="",
            description="Optional: Specify Subnet ID for second private subnet."
        )
        vpc_public_subnet_id1_param = core.CfnParameter(
            self,
            "VpcPublicSubnetId1",
            default="",
            description="Optional: Specify Subnet ID for first public subnet."
        )
        vpc_public_subnet_id2_param = core.CfnParameter(
            self,
            "VpcPublicSubnetId2",
            default="",
            description="Optional: Specify Subnet ID for second public subnet."
        )

        #
        # CONDITIONS
        #
        
        certificate_arn_exists_condition = core.CfnCondition(
            self,
            "CertificateArnExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(certificate_arn_param.value, ""))
        )
        certificate_arn_does_not_exist_condition = core.CfnCondition(
            self,
            "CertificateArnNotExists",
            expression=core.Fn.condition_equals(certificate_arn_param.value, "")
        )
        notification_email_exists_condition = core.CfnCondition(
            self,
            "NotificationEmailExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(notification_email_param.value, ""))
        )
        vpc_given_condition = core.CfnCondition(
            self,
            "VpcGiven",
            expression=core.Fn.condition_not(core.Fn.condition_equals(vpc_id_param.value, ""))
        )
        vpc_not_given_condition = core.CfnCondition(
            self,
            "VpcNotGiven",
            expression=core.Fn.condition_equals(vpc_id_param.value, "")
        )

        #
        # RESOURCES
        #

        # vpc
        vpc = aws_ec2.CfnVPC(
            self,
            "Vpc",
            cidr_block="10.0.0.0/16",
            enable_dns_hostnames=True,
            enable_dns_support=True,
            instance_tenancy="default",
            tags=[core.CfnTag(key="Name", value="{}/Vpc".format(core.Aws.STACK_NAME))]
        )
        vpc.cfn_options.condition=vpc_not_given_condition
        vpc_igw = aws_ec2.CfnInternetGateway(
            self,
            "VpcInternetGateway",
            tags=[core.CfnTag(key="Name", value="{}/Vpc".format(core.Aws.STACK_NAME))]
        )
        vpc_igw.cfn_options.condition=vpc_not_given_condition
        vpc_igw_attachment = aws_ec2.CfnVPCGatewayAttachment(
            self,
            "VpcIGWAttachment",
            vpc_id=vpc.ref,
            internet_gateway_id=vpc_igw.ref
        )
        vpc_igw_attachment.cfn_options.condition=vpc_not_given_condition
        vpc_public_route_table = aws_ec2.CfnRouteTable(
            self,
            "VpcPublicRouteTable",
            vpc_id=vpc.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PublicRouteTable".format(core.Aws.STACK_NAME))]
        )
        vpc_public_route_table.cfn_options.condition=vpc_not_given_condition
        vpc_public_default_route = aws_ec2.CfnRoute(
            self,
            "VpcPublicDefaultRoute",
            route_table_id=vpc_public_route_table.ref,
            destination_cidr_block="0.0.0.0/0",
            gateway_id=vpc_igw.ref
        )
        vpc_public_default_route.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet1 = aws_ec2.CfnSubnet(
            self,
            "VpcPublicSubnet1",
            cidr_block="10.0.0.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(0, core.Fn.get_azs()),
            map_public_ip_on_launch=True,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet1".format(core.Aws.STACK_NAME))
            ]
        )
        vpc_public_subnet1.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet1_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPublicSubnet1RouteTableAssociation",
            route_table_id=vpc_public_route_table.ref,
            subnet_id=vpc_public_subnet1.ref
        )
        vpc_public_subnet1_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet1_eip = aws_ec2.CfnEIP(
            self,
            "VpcPublicSubnet1EIP",
            domain="vpc"
        )
        vpc_public_subnet1_eip.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet1_nat_gateway = aws_ec2.CfnNatGateway(
            self,
            "VpcPublicSubnet1NATGateway",
            allocation_id=vpc_public_subnet1_eip.attr_allocation_id,
            subnet_id=vpc_public_subnet1.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet1".format(core.Aws.STACK_NAME))]
        )
        vpc_public_subnet1_nat_gateway.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet2 = aws_ec2.CfnSubnet(
            self,
            "VpcPublicSubnet2",
            cidr_block="10.0.64.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(1, core.Fn.get_azs()),
            map_public_ip_on_launch=True,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet2".format(core.Aws.STACK_NAME))
            ]
        )
        vpc_public_subnet2.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet2_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPublicSubnet2RouteTableAssociation",
            route_table_id=vpc_public_route_table.ref,
            subnet_id=vpc_public_subnet2.ref
        )
        vpc_public_subnet2_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet2_eip = aws_ec2.CfnEIP(
            self,
            "VpcPublicSubnet2EIP",
            domain="vpc"
        )
        vpc_public_subnet2_eip.cfn_options.condition=vpc_not_given_condition
        vpc_public_subnet2_nat_gateway = aws_ec2.CfnNatGateway(
            self,
            "VpcPublicSubnet2NATGateway",
            allocation_id=vpc_public_subnet2_eip.attr_allocation_id,
            subnet_id=vpc_public_subnet1.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PublicSubnet2".format(core.Aws.STACK_NAME))]
        )
        vpc_public_subnet2_nat_gateway.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet1 = aws_ec2.CfnSubnet(
            self,
            "VpcPrivateSubnet1",
            cidr_block="10.0.128.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(0, core.Fn.get_azs()),
            map_public_ip_on_launch=False,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet1".format(core.Aws.STACK_NAME))
            ]
        )
        vpc_private_subnet1.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet1_route_table = aws_ec2.CfnRouteTable(
            self,
            "VpcPrivateSubnet1RouteTable",
            vpc_id=vpc.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet1".format(core.Aws.STACK_NAME))]
        )
        vpc_private_subnet1_route_table.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet1_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPrivateSubnet1RouteTableAssociation",
            route_table_id=vpc_private_subnet1_route_table.ref,
            subnet_id=vpc_private_subnet1.ref
        )
        vpc_private_subnet1_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet1_default_route = aws_ec2.CfnRoute(
            self,
            "VpcPrivateSubnet1DefaultRoute",
            route_table_id=vpc_private_subnet1_route_table.ref,
            destination_cidr_block="0.0.0.0/0",
            nat_gateway_id=vpc_public_subnet1_nat_gateway.ref
        )
        vpc_private_subnet1_default_route.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet2 = aws_ec2.CfnSubnet(
            self,
            "VpcPrivateSubnet2",
            cidr_block="10.0.192.0/18",
            vpc_id=vpc.ref,
            assign_ipv6_address_on_creation=None,
            availability_zone=core.Fn.select(1, core.Fn.get_azs()),
            map_public_ip_on_launch=False,
            tags=[
                core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet2".format(core.Aws.STACK_NAME))
            ]
        )
        vpc_private_subnet2.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet2_route_table = aws_ec2.CfnRouteTable(
            self,
            "VpcPrivateSubnet2RouteTable",
            vpc_id=vpc.ref,
            tags=[core.CfnTag(key="Name", value="{}/Vpc/PrivateSubnet2".format(core.Aws.STACK_NAME))]
        )
        vpc_private_subnet2_route_table.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet2_route_table_association = aws_ec2.CfnSubnetRouteTableAssociation(
            self,
            "VpcPrivateSubnet2RouteTableAssociation",
            route_table_id=vpc_private_subnet2_route_table.ref,
            subnet_id=vpc_private_subnet2.ref
        )
        vpc_private_subnet2_route_table_association.cfn_options.condition=vpc_not_given_condition
        vpc_private_subnet2_default_route = aws_ec2.CfnRoute(
            self,
            "VpcPrivateSubnet2DefaultRoute",
            route_table_id=vpc_private_subnet2_route_table.ref,
            destination_cidr_block="0.0.0.0/0",
            nat_gateway_id=vpc_public_subnet2_nat_gateway.ref
        )
        vpc_private_subnet2_default_route.cfn_options.condition=vpc_not_given_condition

        # sns
        notification_topic = aws_sns.CfnTopic(
            self,
            "NotificationTopic",
            topic_name="{}-notifications".format(core.Aws.STACK_NAME)
        )
        notification_subscription = aws_sns.CfnSubscription(
            self,
            "NotificationSubscription",
            protocol="email",
            topic_arn=notification_topic.ref,
            endpoint=notification_email_param.value_as_string
        )
        notification_subscription.cfn_options.condition = notification_email_exists_condition
        iam_notification_publish_policy =aws_iam.PolicyDocument(
            statements=[
                aws_iam.PolicyStatement(
                    effect=aws_iam.Effect.ALLOW,
                    actions=[ "sns:Publish" ],
                    resources=[ notification_topic.ref ]
                )
            ]
        )

        # cloudwatch
        system_log_group = aws_logs.CfnLogGroup(
            self,
            "JitsiSystemLogGroup",
            retention_in_days=TWO_YEARS_IN_DAYS
        )
        system_log_group.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        system_log_group.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN

        # AWS::CloudFormation::Interface
        self.template_options.metadata = {
            "OE::Patterns::TemplateVersion": template_version,
            "AWS::CloudFormation::Interface": {
                "ParameterGroups": [
                    {
                        "Label": {
                            "default": "Application Config"
                        },
                        "Parameters": [
                            certificate_arn_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "VPC"
                        },
                        "Parameters": [
                            vpc_id_param.logical_id,
                            vpc_private_subnet_id1_param.logical_id,
                            vpc_private_subnet_id2_param.logical_id,
                            vpc_public_subnet_id1_param.logical_id,
                            vpc_public_subnet_id2_param.logical_id
                        ]
                    }
                ],
                "ParameterLabels": {
                    notification_email_param.logical_id: {
                        "default": "Notification Email"
                    },
                    vpc_id_param.logical_id: {
                        "default": "VPC ID"
                    },
                    vpc_private_subnet_id1_param.logical_id: {
                        "default": "Private Subnet ID 1"
                    },
                    vpc_private_subnet_id2_param.logical_id: {
                        "default": "Private Subnet ID 2"
                    },
                    vpc_public_subnet_id1_param.logical_id: {
                        "default": "Public Subnet ID 1"
                    },
                    vpc_public_subnet_id2_param.logical_id: {
                        "default": "Public Subnet ID 2"
                    }
                }
            }
        }
