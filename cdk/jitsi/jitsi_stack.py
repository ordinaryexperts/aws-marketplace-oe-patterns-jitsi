import os
import subprocess
from aws_cdk import (
    Aws,
    aws_ec2,
    aws_elasticloadbalancingv2,
    aws_iam,
    aws_route53,
    CfnMapping,
    CfnOutput,
    Fn,
    Stack,
    Tags,
    Token
)
from constructs import Construct

from oe_patterns_cdk_common.alb import Alb
from oe_patterns_cdk_common.asg import Asg
from oe_patterns_cdk_common.assets_bucket import AssetsBucket
from oe_patterns_cdk_common.dns import Dns
from oe_patterns_cdk_common.secret import Secret
from oe_patterns_cdk_common.vpc import Vpc

TWO_YEARS_IN_DAYS=731
if 'TEMPLATE_VERSION' in os.environ:
    template_version = os.environ['TEMPLATE_VERSION']
else:
    try:
        template_version = subprocess.check_output(["git", "describe"]).strip().decode('ascii')
    except:
        template_version = "CICD"

# When making a new development AMI:
# 1) $ ave oe-patterns-dev make ami-ec2-build
# 2) $ ave oe-patterns-dev make AMI_ID=ami-fromstep1 ami-ec2-copy
# 3) Copy the code that copy-image generates below

# AMI list generated by:
# make TEMPLATE_VERSION=3.0.0 ami-ec2-build
# on Tue Oct  3 00:23:36 UTC 2023.
AMI_ID="ami-01806c7f836d5ce2a"
AMI_NAME="ordinary-experts-patterns-jitsi-3.0.0-3-g096aa64-20240630-0850"
generated_ami_ids = {
    "ap-northeast-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-northeast-2": "ami-XXXXXXXXXXXXXXXXX",
    "ap-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-2": "ami-XXXXXXXXXXXXXXXXX",
    "ca-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-north-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-2": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-3": "ami-XXXXXXXXXXXXXXXXX",
    "sa-east-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-east-2": "ami-XXXXXXXXXXXXXXXXX",
    "us-west-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-west-2": "ami-XXXXXXXXXXXXXXXXX",
    "us-east-1": "ami-01806c7f836d5ce2a"
}
# End generated code block.

# Sanity check: if this fails then make copy-image needs to be run...
assert AMI_ID == generated_ami_ids["us-east-1"]

class JitsiStack(Stack):

    def __init__(self, scope: Construct, id: str, **kwargs) -> None:
        super().__init__(scope, id, **kwargs)

        ami_mapping={
            "AMI": {
                "AMI": AMI_NAME
            }
        }
        for region in generated_ami_ids.keys():
            ami_mapping[region] = { "AMI": generated_ami_ids[region] }
        CfnMapping(
            self,
            "AWSAMIRegionMap",
            mapping=ami_mapping
        )

        #
        # PARAMETERS
        #


        #
        # RESOURCES
        #

        # vpc
        vpc = Vpc(
            self,
            "Vpc"
        )

        dns = Dns(self, "Dns")

        secret = Secret(self, "Jitsi")

        assets_bucket = AssetsBucket(
            self,
            "AssetsBucket"
        )

        asg_update_secret_policy = aws_iam.CfnRole.PolicyProperty(
            policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[
                            "secretsmanager:DescribeSecret",
                            "secretsmanager:UpdateSecret"
                        ],
                        resources=[secret.secret_arn()]
                    )
                ]
            ),
            policy_name="AllowUpdateInstanceSecret"
        )

        asg_assets_bucket_policy = aws_iam.CfnRole.PolicyProperty(
            policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[
                            "s3:*"
                        ],
                        resources=[ f"{assets_bucket.assets_bucket_arn}/*" ]
                    ),
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[
                            "s3:GetBucketCORS",
                            "s3:GetBucketLocation",
                            "s3:ListBucket",
                            "s3:PutBucketCORS"
                        ],
                        resources=[ assets_bucket.assets_bucket_arn ]
                    )
                ]
            ),
            policy_name="AllowUpdateBucket"
        )

        with open("jitsi/user_data.sh") as f:
            user_data = f.read()
        asg = Asg(
            self,
            "Asg",
            additional_iam_role_policies=[asg_update_secret_policy, asg_assets_bucket_policy],
            default_instance_type="t3.xlarge",
            secret_arns=[secret.secret_arn()],
            singleton=True,
            use_graviton=False,
            user_data_contents=user_data,
            user_data_variables={
                "Hostname": dns.hostname(),
                "SecretArn": secret.secret_arn()
            },
            use_public_subnets=True,
            vpc=vpc
        )

        alb = Alb(
            self,
            "Alb",
            asg=asg,
            health_check_path = "/elb-check",
            vpc=vpc
        )

        nlb_sg = aws_ec2.CfnSecurityGroup(
            self,
            "NlbSg",
            group_description="{}/NlbSg".format(Aws.STACK_NAME),
            security_group_egress=[
                aws_ec2.CfnSecurityGroup.EgressProperty(
                    ip_protocol="-1",
                    cidr_ip="0.0.0.0/0",
                    description="all IPv4 egress traffic allowed"
                )
            ],
            vpc_id=vpc.id()
        )
        Tags.of(nlb_sg).add("Name", "{}/AlbSg".format(Aws.STACK_NAME))
        aws_ec2.CfnSecurityGroupIngress(
            self,
            "NlbSgHttpIngress",
            cidr_ip=alb.ingress_cidr_param.value_as_string,
            description="Allow HTTP traffic to NLB",
            from_port=80,
            group_id=nlb_sg.ref,
            ip_protocol="tcp",
            to_port=80
        )
        aws_ec2.CfnSecurityGroupIngress(
            self,
            "NlbSgHttpsIngress",
            cidr_ip=alb.ingress_cidr_param.value_as_string,
            description="Allow HTTPS traffic to NLB",
            from_port=443,
            group_id=nlb_sg.ref,
            ip_protocol="tcp",
            to_port=443
        )
        aws_ec2.CfnSecurityGroupIngress(
            self,
            "NlbSgJitsiIngress",
            cidr_ip=alb.ingress_cidr_param.value_as_string,
            description="Allow 10000 UDP traffic to NLB",
            from_port=10000,
            group_id=nlb_sg.ref,
            ip_protocol="udp",
            to_port=10000
        )
        aws_ec2.CfnSecurityGroupIngress(
            self,
            "SgAsgJitsiIngress",
            description="Allow 10000 UDP traffic from NLB to ASG",
            from_port=10000,
            group_id=asg.sg.ref,
            ip_protocol="udp",
            source_security_group_id=nlb_sg.ref,
            to_port=10000
        )

        nlb = aws_elasticloadbalancingv2.CfnLoadBalancer(
            self,
            "AppNlb",
            scheme="internet-facing",
            security_groups=[ nlb_sg.ref ],
            subnets=vpc.public_subnet_ids(),
            type="network"
        )
        Tags.of(nlb).add(
            "vpc-igw-attachment",
            Token.as_string(
                Fn.condition_if(
                    vpc.not_given_condition.logical_id,
                    Fn.select(0, Fn.split('|', vpc.igw_attachment.ref)),
                    "provided-by-user"
                )
            )
        )
        nlb.add_dependency(alb.http_listener)
        nlb.add_dependency(alb.https_listener)
        
        nlb_http_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "NlbHttpTargetGroup",
            port=80,
            protocol="TCP",
            target_type="alb",
            targets=[aws_elasticloadbalancingv2.CfnTargetGroup.TargetDescriptionProperty(
                id=alb.alb.ref
            )],
            vpc_id=vpc.id()
        )
        aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpListener",
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=nlb_http_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=nlb.ref,
            port=80,
            protocol="TCP"
        )

        nlb_https_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "NlbHttpsTargetGroup",
            port=443,
            protocol="TCP",
            target_type="alb",
            targets=[aws_elasticloadbalancingv2.CfnTargetGroup.TargetDescriptionProperty(
                id=alb.alb.ref
            )],
            vpc_id=vpc.id()
        )
        aws_elasticloadbalancingv2.CfnListener(
            self,
            "NlbHttpsListener",
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=nlb_https_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=nlb.ref,
            port=443,
            protocol="TCP"
        )

        jitsi_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "JitsiTargetGroup",
            port=10000,
            protocol="UDP",
            target_type="instance",
            vpc_id=vpc.id()
        )
        aws_elasticloadbalancingv2.CfnListener(
            self,
            "JitsiListener",
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=jitsi_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=nlb.ref,
            port=10000,
            protocol="UDP"
        )

        asg.asg.target_group_arns = [jitsi_target_group.ref, alb.target_group.ref]

        record_set = aws_route53.CfnRecordSetGroup(
            self,
            "RecordSetGroup",
            hosted_zone_name=f"{dns.route_53_hosted_zone_name_param.value_as_string}.",
            comment=dns.hostname_param.value_as_string,
            record_sets=[
                aws_route53.CfnRecordSetGroup.RecordSetProperty(
                    name=f"{dns.hostname_param.value_as_string}.",
                    type="A",
                    alias_target=aws_route53.CfnRecordSetGroup.AliasTargetProperty(
                        dns_name=nlb.attr_dns_name,
                        hosted_zone_id=nlb.attr_canonical_hosted_zone_id
                    )
                )
            ]
        )
        asg.asg.add_dependency(record_set)

        CfnOutput(
            self,
            "SiteUrlOutput",
            description="The URL Endpoint",
            value=Token.as_string(
                Fn.condition_if(
                dns.hostname_exists_condition.logical_id,
                "https://{}".format(dns.hostname_param.value_as_string),
                "https://{}".format(nlb.attr_dns_name)
            ))
        )

        # AWS::CloudFormation::Interface
        self.template_options.metadata = {
            "OE::Patterns::TemplateVersion": template_version,
            "AWS::CloudFormation::Interface": {
                "ParameterGroups": [
                    *alb.metadata_parameter_group(),
                    *asg.metadata_parameter_group(),
                    *dns.metadata_parameter_group(),
                    *secret.metadata_parameter_group(),
                    *vpc.metadata_parameter_group()
                ],
                "ParameterLabels": {
                    **alb.metadata_parameter_labels(),
                    **asg.metadata_parameter_labels(),
                    **dns.metadata_parameter_labels(),
                    **secret.metadata_parameter_labels(),
                    **vpc.metadata_parameter_labels()
                }
            }
        }
